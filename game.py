import pygame
from Graph import Graph
import settings
from tools import *
from GameUI import GameUI


class Event:
	"""this is a superclass for any events that might be generated by an
	object and sent to the EventManager"""

	def __init__(self):
		self.name = "Generic Event"


class QuitEvent(Event):
	def __init__(self):
		super().__init__()
		self.name = "Quit Event"


class TickEvent(Event):
	def __init__(self):
		super().__init__()
		self.name = "Tick Event"


class LeftClicPressedEvent(Event):
	def __init__(self):
		super().__init__()
		self.name = "Left Clic Event"


class RightClicPressedEvent(Event):
	def __init__(self):
		super().__init__()
		self.name = "Right Clic Event"


class ChangeModeEvent(Event):
	def __init__(self, mode):
		super().__init__()
		self.name = "Change Mode Event"
		self.mode = mode


class ToggleDebugEvent(Event):
	def __init__(self):
		super().__init__()
		self.name = "Toggle Debug Event"


class EventManager:
	"""this object is responsible for coordinating most communication
	between the Model, View, and Controller."""

	def __init__(self):
		from weakref import WeakKeyDictionary
		self.listeners = WeakKeyDictionary()
		self.eventQueue = []

	def register_listener(self, listener):
		self.listeners[listener] = 1

	def unregister_listener(self, listener):
		if listener in self.listeners.keys():
			del self.listeners[listener]

	def post(self, event):
		if not isinstance(event, TickEvent):
			print("     Message: " + event.name)
		for listener in self.listeners.keys():
			# NOTE: If the weakref has died, it will be
			# automatically removed, so we don't have
			# to worry about it.
			listener.notify(event)


class Listener:

	def __init__(self, evManager):
		if evManager is not None:
			evManager.register_listener(self)

	def notify(self, event):
		pass


class Map(Listener):

	def __init__(self, evManager):
		super().__init__(evManager)
		self.evManager = evManager

		self.startingPoint = None
		self.endingPoint = None
		self.crossing = False
		self.points = []
		self.lines = []


class KeyboardController(Listener):

	def __init__(self, evManager):
		super().__init__(evManager)
		self.evManager = evManager

	def notify(self, event):
		if isinstance(event, TickEvent):
			for event in pygame.event.get():

				ev = None

				# Quit event from pygame
				if event.type == pygame.QUIT:
					ev = QuitEvent()

				# If keyboard key is pressed
				if event.type == pygame.KEYDOWN:

					# "ESC" to Quit
					if event.key == pygame.K_ESCAPE:
						ev = QuitEvent()

					# "P" to enter Point editing mode
					if event.key == pygame.K_p:
						ev = ChangeModeEvent("Point Editing")

					# "L" to enter Line editing mode
					if event.key == pygame.K_l:
						ev = ChangeModeEvent("Line Editing")

					# "F" to Finish editing
					if event.key == pygame.K_f:
						ev = ChangeModeEvent("Play Mode")

					# "D" to enter Debug mode
					if event.key == pygame.K_d:
						ev = ToggleDebugEvent()

				# If mouse is pressed
				if event.type == pygame.MOUSEBUTTONDOWN:

					# Left clic pressed
					if event.button == 1:
						ev = LeftClicPressedEvent()

					# Right clic pressed
					if event.button == 3:
						ev = RightClicPressedEvent()

				if ev is not None:
					self.evManager.post(ev)


class GameController(Listener):

	def __init__(self, evManager):
		super().__init__(evManager)
		self.evManager = evManager

		self.keepGoing = 1

	def run(self):
		clock = pygame.time.Clock()
		elapsed_frames = 0
		while self.keepGoing:
			delay = clock.tick(100)
			if elapsed_frames % 100 == 1:
				print(delay)

			self.evManager.post(TickEvent())
			elapsed_frames += 1

	def notify(self, event):
		if isinstance(event, QuitEvent):
			self.keepGoing = 0


class Game(Listener):

	def __init__(self, evManager):
		super().__init__(evManager)
		self.evManager = evManager

		self.map = Map(evManager)

		self.pointEditing = True
		self.lineEditing = False

		print("Press P to edit points, L to edit lines, F when you've finished, D for debug and ESC to quit")

	def start(self):
		pass

	def notify(self, event):
		if isinstance(event, ChangeModeEvent):
			if event.mode == 'Point Editing':
				self.lineEditing = False
				self.pointEditing = True
			elif event.mode == 'Line Editing':
				self.pointEditing = False
				self.lineEditing = True
			elif event.mode == 'Play mode':
				self.pointEditing = False
				self.lineEditing = False


class PygameView(Listener):

	def __init__(self, evManager):
		super().__init__(evManager)
		self.evManager = evManager

		pygame.init()
		self.screen = pygame.display.set_mode((settings.WIDTH, settings.HEIGHT))

	def notify(self, event):
		if isinstance(event, TickEvent):
			pass
		# Draw Everything


def main():
	evManager = EventManager()

	keybd = KeyboardController(evManager)
	game = Game(evManager)
	gameController = GameController(evManager)
	pygameView = PygameView(evManager)

	gameController.run()


if __name__ == "__main__":
	main()

	# Initialize pygame
	pygame.init()

	gameUI = GameUI()

	# Level creation
	pointEditing = True
	lineEditing = False
	startingPoint = None
	endingPoint = None
	crossing = False
	points = []
	lines = []

	# Level design
	backgroundColor = (20, 60, 20)
	roadColor = (100, 100, 100)
	roadWidth = 50

	# Reward gates
	rewardGates = []
	spaceBetweenGates = 50

	# Graph creation
	graph = None

	# Game Loop
	running = True
	while running:

		# Event handling
		for event in pygame.event.get():

			# If the red cross in the upper right corner is clicked
			if event.type == pygame.QUIT:
				running = False

			if event.type == pygame.MOUSEBUTTONDOWN:

				# Left clic
				if event.button == 1:

					# Line creation
					if lineEditing:
						mouseX, mouseY = pygame.mouse.get_pos()
						for position in points:
							if math.hypot(position[0] - mouseX, position[1] - mouseY) <= 40:
								if startingPoint is None:
									startingPoint = position
								elif position != startingPoint and not crossing:
									endingPoint = position

				# Right clic
				if event.button == 3:

					# Point removing
					if pointEditing:
						mouseX, mouseY = pygame.mouse.get_pos()
						position_to_remove = None
						for position in points:
							if math.hypot(position[0] - mouseX, position[1] - mouseY) <= 40:
								removePos = position
								position_to_remove = position
								break

						# Remove the point and all lines connected to it
						if position_to_remove is not None:
							points.remove(position_to_remove)
							for line in reversed(lines):
								if position_to_remove in line:
									lines.remove(line)

					# Cancel the new line drawing
					if lineEditing:
						startingPoint = None

			# If keyboard key is pressed
			if event.type == pygame.KEYDOWN:

				# "P" to enter Point editing mode
				if event.key == pygame.K_p:
					pointEditing = True
					lineEditing = False
					graph = None

				# "L" to enter Line editing mode
				if event.key == pygame.K_l:
					lineEditing = True
					pointEditing = False
					graph = None

				# "F" to Finish editing
				if event.key == pygame.K_f:
					if len(points) > 0:
						gameUI.change_car_position(Vector2(points[0]))

					lineEditing = False
					pointEditing = False
					graph = Graph(points, lines)

				# "D" to enter Debug mode
				if event.key == pygame.K_d:
					settings.DEBUG = not settings.DEBUG

				# "ESC" to Quit
				if event.key == pygame.K_ESCAPE:
					running = False

		# Change the background color
		gameUI.draw_background()

		# Level editing GUI
		if pointEditing:
			gameUI.point_editing(points)
		elif lineEditing:
			startingPoint, endingPoint = gameUI.line_editing(points, lines, startingPoint, endingPoint)

		# Level out of editing mode
		else:
			gameUI.game(points, lines)

		# Always update the display at the end of the loop
		pygame.display.update()
